//
// Created by mslf on 10/6/16.
//
/*
	Copyright 2016 Golikov Vitaliy

	This file is part of Alone.

	Alone is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Alone is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Alone. If not, see <http://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include "textParser/TextParser.h"

const char* const TEXT_PARSER_ERR_OPERANDS_ALLOC =
        "TextParser_parseTextResource: allocating memory for operands failed!";
const char* const TEXT_PARSER_ERR_SYNTAX_DELETE_COMMENTS =
        "TextParser_parseTextResource: syntax error or unexpected EOF while deleting comments!";
const char* const TEXT_PARSER_ERR_UNEXPEXTED_EOF_SPLIT_EXPRESSION =
        "TextParser_parseTextResource: unexpected end of file while splitting expression!";
const char* const TEXT_PARSER_ERR_SYNTAX_SPLIT_EXPRESSION =
        "TextParser_parseTextResource: syntax error while splitting expression!";
const char* const TEXT_PARSER_ERR_PAIRS_REALLOC =
        "TextParser_reallocatePairsList: reallocating memory for pairsList failed!";
const char* const TEXT_PARSER_ERR_ITEMS_REALLOC =
        "TextParser_reallocateItemsList: reallocating memory for itemsList failed!";
const char* const TEXT_PARSER_ERR_ITEMS_ALLOC =
        "TextParser_reallocatePairsList: allocating memory for itemsList failed!";
const char* const TEXT_PARSER_ERR_STRING_REALLOC =
        "TextParser_reallocateString: reallocating memory for string failed!";
const char* const TEXT_PARSER_ERR_LEFT_OPERAND_STRING_ALLOC =
        "TextParser_addPair: allocating memory for leftValue failed!";
const char* const TEXT_PARSER_ERR_SYNTAX_QUOTES =
        "TextParser_addPair: syntax error: odd count of quotes!";
const char* const TEXT_PARSER_ERR_UNEXPEXTED_EOF_ITEMS_ARRAY_STRING =
        "TextParser_addPair: unexpected end of file while parsing items array string!";
const char* const TEXT_PARSER_ERR_SYNTAX_BRACKETS =
        "TextParser_addPair: syntax error: opening and closing square-brackets not found!";
const char* const TEXT_PARSER_ERR_ADD_ITEM =
        "TextParser_addItemToRightValue: adding item failed!";
const char* TEXT_PARSER_HEADER_COMMENT = "This text resource was generated by TextParser from Alone";

/*
 * We don't check logger to NULL in here, because it is not mandatory.
 */

static unsigned char TextParser_reallocatePairsList(struct Logger* logger, struct TextParser* textParser) {
    if (!textParser)
        return 1;
    struct Pair* newPairsList = NULL;
    size_t newSize = textParser->allocatedPairsCount + INITIAL_NUMBER_ALLOCATED_PAIRS;
    size_t i;
    newPairsList = (struct Pair*)malloc(sizeof(struct Pair) * newSize);
    if (!newPairsList) {
        Logger_log(logger, TEXT_PARSER_ERR_PAIRS_REALLOC);
        return 2;
    }
    for (i = 0; i < textParser->pairsCount; i++)
        newPairsList[i] = textParser->pairsList[i];
    for (i = textParser->allocatedPairsCount; i < newSize; i++){
        newPairsList[i].rightValue.itemsCount = 0;
        if (!(newPairsList[i].rightValue.itemsList =
                    (char**)malloc(sizeof(char*) * INITIAL_NUMBER_ALLOCATED_ITEMS))) {
            free(newPairsList);
            return 3;
        }
        newPairsList[i].rightValue.allocatedItemsCount = INITIAL_NUMBER_ALLOCATED_ITEMS;
    }
    free(textParser->pairsList);
    textParser->pairsList = newPairsList;
    textParser->allocatedPairsCount = newSize;
    return 0;
}

static unsigned char TextParser_reallocateItemsList(struct Logger* logger, struct RightValue* rightValue) {
    if (!rightValue)
        return 1;
    char** newItemsList = NULL;
    size_t newSize = rightValue->allocatedItemsCount + INITIAL_NUMBER_ALLOCATED_ITEMS;
    size_t i;
    newItemsList = (char**)malloc(sizeof(char*) * newSize);
    if (!newItemsList) {
        Logger_log(logger, TEXT_PARSER_ERR_ITEMS_REALLOC);
        return 2;
    }
    for(i = 0; i < rightValue->itemsCount; i++)
        newItemsList[i] = rightValue->itemsList[i];
    free(rightValue->itemsList);
    rightValue->itemsList = newItemsList;
    rightValue->allocatedItemsCount = newSize;
    return  0;
}

//? consider using asserts maybe
static unsigned char TextParser_reallocateString(struct Logger* logger, char** string, size_t* oldLength, size_t step) {
    if (!string || !oldLength || !step)
        return 1;
    char* newString = NULL;
    size_t i;
    size_t newLength = (*oldLength) + step;
    newString = (char*)malloc(sizeof(char) * newLength);
    if (!newString) {
        Logger_log(logger, TEXT_PARSER_ERR_STRING_REALLOC);
        return 2;
    }
    for (i = 0; i < (*oldLength); i++)
        newString[i] = (*string)[i];
    free((*string));
    (*string) = newString;
    (*oldLength) = newLength;
    return  0;
}

static unsigned char TextParser_splitExpression(struct Logger* logger, const char* const string, size_t* startIndex,
                                                char** leftValueString,
                                                size_t* leftCounter, size_t* allocatedCharsForLeftOperand,
                                                char** rightValueString, size_t* rightCounter,
                                                size_t* allocatedCharsForRightValue) {
    if (!string || !startIndex || !leftValueString || !leftCounter 
        || !allocatedCharsForLeftOperand || !rightValueString || !rightCounter || !allocatedCharsForRightValue)
        return 7;
    unsigned char state = 0;
    while ((*startIndex) < strlen(string) && state != 3 && state != 4) {
        char c = string[*startIndex];
        if ((*leftCounter) >= (*allocatedCharsForLeftOperand))
            if (TextParser_reallocateString(logger, leftValueString, allocatedCharsForLeftOperand,
                                            INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_LEFT_OPERAND_STRING))
                return 5;
        if ((*rightCounter) >= (*allocatedCharsForRightValue))
            if (TextParser_reallocateString(logger, rightValueString, allocatedCharsForRightValue,
                                            INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_RIGHT_OPERAND_STRING))
                return 6;


        //? You can use goto with case labels.
        switch (state) {
            case 0: // start
                if (c == ';'){
                    state = 4;
                    break;
                }
                if (c != ' ' && c!= '\t' && c!= '\n') {
                    state = 1;
                    (*leftValueString)[*leftCounter] = c;
                    (*leftCounter)++;
                }
                break;
            case 1: // onLeftPart
                if (c == '=' && (*leftCounter) > 0) {
                    state = 2;
                    break;
                }
                if (c == '=' && (*leftCounter) == 0) {
                    state = 4;
                    break;
                }
                if (c == '\n' || c == ';') {
                    state = 4;
                    break;
                }
                if (c != ' ' && c != '\t') {
                    (*leftValueString)[*leftCounter] = c;
                    (*leftCounter)++;
                }
                break;
            case 2: // onRightPart
                if (c == ';' && (*rightCounter) > 0) {
                    state = 3;
                    break;
                }
                if (c == ';' && (*rightCounter) == 0) {
                    state = 4;
                    break;
                }
                (*rightValueString)[*rightCounter] = c;
                (*rightCounter)++;
                break;
            case 3: // end
                break;
            case 4: // syntax error
                break;
        }
        (*startIndex)++;
    }
    return state;
}

static unsigned char TextParser_deleteNonQuotedSpaces(char* rightValueString, size_t* rightCounter) {
    if (!rightValueString || !rightCounter)
        return 2;
    unsigned char state = 0;
    size_t i = 0;
    size_t j = 0;
    size_t quotesCount = 0;
    while (i < (*rightCounter)) {
        char c = rightValueString[i];
        switch (state) {
            case 0: // notInQuotes
                if (c == '\"') {
                    state = 1;
                    quotesCount++;
                    break;
                }
                if (c == ' ' || c == '\t' || c == '\n') {
                    for (j = i; j < (*rightCounter) - 1; j++)
                        rightValueString[j] = rightValueString[j + 1];
                    (*rightCounter)--;
                    i--;
                }
                break;
            case 1: // inQuotes
                if (c == '\"') {
                    state = 0;
                    quotesCount++;
                    break;
                }
                if (c == '\n') {
                    for (j = i; j < (*rightCounter) - 1; j++)
                        rightValueString[j] = rightValueString[j + 1];
                    (*rightCounter)--;
                    i--;
                }
                break;
        }
        i++;
    }
    return (quotesCount % 2);
}

static unsigned char TextParser_addItemToRightValue(struct Logger* logger, struct Pair* pair,
                                                      const char* const itemString,
                                                      size_t itemStringLength) {
    if (!pair || !itemString || !itemStringLength)
        return 1;
    size_t i = 0;
    if (pair->rightValue.itemsCount >=
            pair->rightValue.allocatedItemsCount)
        if (TextParser_reallocateItemsList(logger, &(pair->rightValue)))
            return 2;
    pair->rightValue.itemsList[pair->rightValue.itemsCount] =
            (char*)malloc(sizeof(char) * (itemStringLength + 1));
    if (!pair->rightValue.itemsList[pair->rightValue.itemsCount]) {
        Logger_log(logger, TEXT_PARSER_ERR_ADD_ITEM);
        return 3;
    }
    for (i = 0; i < itemStringLength; i ++)
        pair->rightValue.itemsList[pair->rightValue.itemsCount][i] = itemString[i];
    pair->rightValue.itemsList[pair->rightValue.itemsCount][itemStringLength] = 0;
    pair->rightValue.itemsCount++;
    return 0;
}

static unsigned char TextParser_parseItemsArrayString(struct Logger* logger, struct Pair* pair, char* itemsString,
                                               size_t itemsStringLength) {
    if (!pair || !itemsString || !itemsStringLength)
        return 6;
    unsigned char state = 0;
    size_t i = 1; // start from first symbol, because zero-zymbol is '['
    char* tempItemString = NULL;
    tempItemString = (char*)malloc(sizeof(char) * INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_ITEM_STRING);
    if (!tempItemString)
        return 7;
    size_t allocatedCharsForTempItemString = INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_ITEM_STRING;
    size_t charsCounter = 0;
    while (i < itemsStringLength && state != 3 && state != 4) {
        char c = itemsString[i];
        if (charsCounter >= allocatedCharsForTempItemString)
            if (TextParser_reallocateString(logger, &tempItemString, &allocatedCharsForTempItemString,
                                            INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_ITEM_STRING)) {
                free(tempItemString);
                return 5;
            }
        switch (state) {
            case 0: // buildingItemString_NotInQuotes
                if (c == '\"') {
                    state = 1;
                    break;
                }
                if (c == ']') {
                    if (charsCounter > 0) {
                        TextParser_addItemToRightValue(logger, pair, tempItemString, charsCounter);
                        charsCounter = 0;
                        state = 3;
                    } else
                        state = 4;
                    break;
                }
                if (c == ',') {
                    TextParser_addItemToRightValue(logger, pair, tempItemString, charsCounter);
                    charsCounter = 0;
                    break;
                }
                tempItemString[charsCounter] = c;
                charsCounter++;
                break;
            case 1: // buildingItemString_InQuotes
                if (c == '\"') {
                    if (charsCounter > 0) {
                        TextParser_addItemToRightValue(logger, pair, tempItemString, charsCounter);
                        charsCounter = 0;
                        state = 2;
                    } else
                        state = 4;
                    break;
                }
                tempItemString[charsCounter] = c;
                charsCounter++;
                break;
            case 2: // checkingEnd
                if (c == ',') {
                    state = 0;
                    break;
                }
                if (c == ']') {
                    state = 3;
                    break;
                }
                state = 4;
                break;
            case 3: // end
                break;
            case 4: // syntax error
                break;
        }
        i++;
    }
    free(tempItemString);
    return state;
}

static void TextParser_destructTempOperandStrings(char* left, char* right) {
    if (left)
        free(left);
    if (right)
        free(right);
}

static unsigned char TextParser_addPair(struct Logger* logger, struct TextParser* textParser, char* leftValueString,
                                 size_t leftCounter, char* rightValueString, size_t rightCounter) {
    if (!textParser || !leftValueString || !leftCounter || !rightValueString || !rightCounter)
        return 1;
    size_t j;
    // adding leftValueString string as a leftValue to the pair
    if (textParser->pairsCount >= textParser->allocatedPairsCount)
        if (TextParser_reallocatePairsList(logger, textParser)) {
            TextParser_destructTempOperandStrings(leftValueString, rightValueString);
            return  2;
        }
    textParser->pairsList[textParser->pairsCount].leftValue = (char*)malloc(sizeof(char) * (leftCounter + 1));
    if (!textParser->pairsList[textParser->pairsCount].leftValue) {
        Logger_log(logger, TEXT_PARSER_ERR_LEFT_OPERAND_STRING_ALLOC);
        TextParser_destructTempOperandStrings(leftValueString, rightValueString);
        return 3;
    }
    for (j = 0; j < leftCounter; j ++)
        textParser->pairsList[textParser->pairsCount].leftValue[j] =  leftValueString[j];
    textParser->pairsList[textParser->pairsCount].leftValue[leftCounter] = 0;
    // Working with rightValue
    if (TextParser_deleteNonQuotedSpaces(rightValueString, &rightCounter)) {
        Logger_log(logger, TEXT_PARSER_ERR_SYNTAX_QUOTES);
        TextParser_destructTempOperandStrings(leftValueString, rightValueString);
        return 4;
    }
    if (rightValueString[0] == '[' && rightValueString[rightCounter - 1] == ']') {
        if (TextParser_parseItemsArrayString(logger, &(textParser->pairsList[textParser->pairsCount]),
                                             rightValueString, rightCounter) != 3) {
            Logger_log(logger, TEXT_PARSER_ERR_UNEXPEXTED_EOF_ITEMS_ARRAY_STRING);
            TextParser_destructTempOperandStrings(leftValueString, rightValueString);
            return 5;
        }
    } else { // adding rightValueString as a first item to the pair
        if (rightValueString[0] == '[' || rightValueString[rightCounter - 1] == ']') {
            Logger_log(logger, TEXT_PARSER_ERR_SYNTAX_BRACKETS);
            TextParser_destructTempOperandStrings(leftValueString, rightValueString);
            return 6;
        }
        if (TextParser_addItemToRightValue(logger, &(textParser->pairsList[textParser->pairsCount]),
                                             rightValueString, rightCounter)) {
            TextParser_destructTempOperandStrings(leftValueString, rightValueString);
            return 7;
        }
    }
    textParser->pairsCount++;
    return 0;
}

static unsigned char TextParser_deleteComments(char* const srcText, char** dstText) {
    if (!srcText || !dstText)
        return 4;
    size_t length = strlen(srcText);
    *(dstText) = (char*)malloc(sizeof(char) * (length + 1));
    if (!(*dstText))
        return 5;
    unsigned char state = 0;
    size_t counter = 0;
    size_t i = 0;
    while (i < length) {
        char c = srcText[i];
        switch (state) {
            case 0: // normal text
                if (c == '/') {
                    state = 1;
                    break;
                }
                (*dstText)[counter] = c;
                counter++;
                break;
            case 1: // on "/" (entering comment block)
                if (c == '*') {
                    state = 2;
                    break;
                }
                (*dstText)[counter] = '/';
                counter++;
                (*dstText)[counter] = c;
                counter++;
                state = 0;
                break;
            case 2: // in comment block
                if (c == '*')
                    state = 3;
                break;
            case 3: // on "*" (exiting comment block)
                if (c == '/') {
                    state = 0;
                    break;
                }
                state = 2;
                break;
        }
        i++;
    }
    (*dstText)[counter] = 0;
    return state;
}

static unsigned char TextParser_parseTextResource(struct Logger* logger, struct TextParser* textParser,
                                           const struct TextResource* const textResource) {
    if (!textParser || !textResource)
        return 1;
    char* leftValueString = NULL;
    char* rightValueString = NULL;
    leftValueString = (char*)malloc(sizeof(char) * INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_LEFT_OPERAND_STRING);
    rightValueString = (char*)malloc(sizeof(char) * INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_RIGHT_OPERAND_STRING);
    if (!leftValueString || !rightValueString) {
        Logger_log(logger, "%s ResourceID: %s", TEXT_PARSER_ERR_OPERANDS_ALLOC, textResource->id);
        TextParser_destructTempOperandStrings(leftValueString, rightValueString);
        return 2;
    }
    size_t allocatedCharsForLeftOperand = INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_LEFT_OPERAND_STRING;
    size_t allocatedCharsForRightValue = INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_RIGHT_OPERAND_STRING;
    size_t leftCounter = 0;
    size_t rightCounter = 0;
    size_t i = 0;
    size_t j = 0;
    unsigned char state = 0;
    char* tempText = NULL;
    if (TextParser_deleteComments(textResource->text, &tempText)) {
        Logger_log(logger, TEXT_PARSER_ERR_SYNTAX_DELETE_COMMENTS);
        return 3;
    }
    while (i < strlen(tempText)) {
        leftCounter = 0;
        rightCounter = 0;
        state = TextParser_splitExpression(logger, tempText, &i, &leftValueString, &leftCounter,
                                           &allocatedCharsForLeftOperand, &rightValueString, &rightCounter,
                                           &allocatedCharsForRightValue);
        if (state != 3 && state != 4 && state != 0) {
            Logger_log(logger, "%s ResourceID: %s", TEXT_PARSER_ERR_UNEXPEXTED_EOF_SPLIT_EXPRESSION, textResource->id);
            TextParser_destructTempOperandStrings(leftValueString, rightValueString);
            return 4;
        }
        if (state == 4) {
            Logger_log(logger, "%s ResourceID: %s", TEXT_PARSER_ERR_SYNTAX_SPLIT_EXPRESSION, textResource->id);
            TextParser_destructTempOperandStrings(leftValueString, rightValueString);
            return 5;
        }
        if (state == 3) {
            unsigned char result = TextParser_addPair(logger, textParser, leftValueString, leftCounter,
                                                      rightValueString, rightCounter);
            if (result) {
                Logger_log(logger, "\t in ResourceID: %s", textResource->id);
                return (result + 5);
            }

        }
    }
    free(tempText);
    TextParser_destructTempOperandStrings(leftValueString, rightValueString);
    return 0;
}

struct TextParser* TextParser_constructFromTextResource(struct Logger* logger,
                                                        const struct TextResource* const textResource) {
    if (!textResource)
        return NULL;
    struct TextParser* textParser = NULL;
    textParser = TextParser_constructEmpty();
    if (!textParser)
        return NULL;
    if (TextParser_parseTextResource(logger, textParser, textResource)) {
        TextParser_destruct(textParser);
        return  NULL;
    }
    return textParser;
}

struct TextParser* TextParser_constructEmpty() {
    struct TextParser* textParser = NULL;
    textParser = (struct TextParser*)calloc(1, sizeof(struct TextParser));
    if (!textParser)
        return NULL;
    textParser->pairsCount = 0;
    textParser->pairsList = (struct Pair*)malloc(sizeof(struct Pair) * INITIAL_NUMBER_ALLOCATED_PAIRS);
    if (!textParser->pairsList) {
        TextParser_destruct(textParser);
        return NULL;
    }
    textParser->allocatedPairsCount = INITIAL_NUMBER_ALLOCATED_PAIRS;
    size_t i;
    for (i = 0; i < textParser->allocatedPairsCount; i++){
        textParser->pairsList[i].rightValue.itemsCount = 0;
        if (!(textParser->pairsList[i].rightValue.itemsList =
                    (char**)malloc(sizeof(char*) * INITIAL_NUMBER_ALLOCATED_ITEMS))) {
            TextParser_destruct(textParser);
            return NULL;
        }
        textParser->pairsList[i].rightValue.allocatedItemsCount = INITIAL_NUMBER_ALLOCATED_ITEMS;
    }
    textParser->lastError = NoError;
    return textParser;
}

void TextParser_destruct(struct TextParser* textParser) {
    if (!textParser)
        return;
    if (textParser->pairsList) {
        size_t i;
        size_t j;
        for (i = 0; i < textParser->allocatedPairsCount; i++){
            if (i < textParser->pairsCount)
                free(textParser->pairsList[i].leftValue);
            if (i < textParser->pairsCount)
                for (j = 0; j < textParser->pairsList[i].rightValue.itemsCount; j++)
                    free(textParser->pairsList[i].rightValue.itemsList[j]);
            free(textParser->pairsList[i].rightValue.itemsList);
        }
        free(textParser->pairsList);
    }
    free(textParser);
}

size_t TextParser_getItemsCount(struct TextParser* textParser, const char* const leftValue) {
    if (!textParser || !leftValue)
        return 0;
    size_t i = 0;
    for (i = 0; i < textParser->pairsCount; i++)
        if (strcmp(leftValue, textParser->pairsList[i].leftValue) == 0) {
            textParser->lastError = NoError;
            return textParser->pairsList[i].rightValue.itemsCount;
        }
    textParser->lastError = NoLeftOperandError;
    return 0;
}

const char* TextParser_getString(struct TextParser* textParser, const char* const leftValue, size_t index) {
    if (!textParser)
        return NULL;
    if (!leftValue) {
        textParser->lastError = NoLeftOperandError;
        return NULL;
    }
    size_t i = 0;
    unsigned char found = 0;
    size_t foundIndex = 0;
    for (i = 0; i < textParser->pairsCount; i++)
        if (strcmp(leftValue, textParser->pairsList[i].leftValue) == 0) {
            found = 1;
            foundIndex = i;
            break;
        }
    if (!found) {
        textParser->lastError = NoLeftOperandError;
        return NULL;
    }
    if (index >= textParser->pairsList[foundIndex].rightValue.itemsCount) {
        textParser->lastError = OutOfRangeError;
        return NULL;
    }
    textParser->lastError = NoError;
    return textParser->pairsList[foundIndex].rightValue.itemsList[index];
}

long int TextParser_getInt(struct TextParser* textParser, const char* const leftValue, size_t index) {
    const char* intString = TextParser_getString(textParser, leftValue, index);
    if (textParser->lastError)
        return 0;
    return strtol(intString, NULL, 10);
}

double TextParser_getDouble(struct TextParser* textParser, const char* leftValue, size_t index) {
    const char* intString = TextParser_getString(textParser, leftValue, index);
    if (textParser->lastError)
        return 0.0;
    return strtod(intString, NULL);
}

bool TextParser_getFlag(struct TextParser* textParser, const char* const leftValue, size_t index){
    const char* intString = TextParser_getString(textParser, leftValue, index);
    if (textParser->lastError)
        return false;
    if (strtol(intString, NULL, 10))
        return true;
    else
        return false;
}

unsigned char TextParser_addString(struct TextParser* textParser, const char* const leftValue, const char* const item) {
    if (!textParser || !leftValue || !item)
        return 1;
    TextParser_getItemsCount(textParser, leftValue); // later, we will use textParser->lastError. Don't remove this.
    size_t found = 0;
    size_t index = 0;
    size_t i = 0;
    if (textParser->lastError == NoLeftOperandError) {
        if (textParser->pairsCount >= textParser->allocatedPairsCount)
            if (TextParser_reallocatePairsList(NULL, textParser)) {
                textParser->lastError = MemoryAllocationError;
                return 2;
            }
        char* tempLeftOperandString = NULL;
        tempLeftOperandString = (char*)malloc(sizeof(char) * (strlen(leftValue) + 1));
        if (!tempLeftOperandString) {
            textParser->lastError = MemoryAllocationError;
            return 3;
        }
        strcpy(tempLeftOperandString, leftValue);
        textParser->pairsList[textParser->pairsCount].leftValue = tempLeftOperandString;
        index = textParser->pairsCount;
        textParser->pairsCount++;
    } else if (textParser->lastError == NoError)
        for (i = 0; i < textParser->pairsCount; i++)
            if (strcmp(leftValue, textParser->pairsList[i].leftValue) == 0) {
                found = 1;
                index = i;
                break;
            }
    if (TextParser_addItemToRightValue(NULL, &(textParser->pairsList[index]), item, strlen(item))) {
        textParser->lastError = MemoryAllocationError;
        if (!found) {
            free (textParser->pairsList[index].leftValue);
            textParser->pairsCount--;
        }
        return 4;
    }
    textParser->lastError = NoError;
    return 0;
}

unsigned char TextParser_addInt(struct TextParser* textParser, const char* const leftValue, long int item) {
    char tempString[100];
    sprintf(tempString, "%ld", item);
    return TextParser_addString(textParser, leftValue, tempString);
}

unsigned char TextParser_addDouble(struct TextParser* textParser, const char* leftValue, double item) {
    char tempString[100];
    sprintf(tempString, "%f", item);
    return TextParser_addString(textParser, leftValue, tempString);
}

unsigned char TextParser_addFlag(struct TextParser* textParser, const char* const leftValue, bool item) {
    char tempString[2];
    if (item)
        sprintf(tempString, "1");
    else
        sprintf(tempString, "0");
    return TextParser_addString(textParser, leftValue, tempString);
}

static unsigned char TextParser_checkWroteCounter(struct TextParser* textParser, size_t wrote, size_t* counter,
                                           size_t* allocatedLength, char** string) {
    if (!textParser || !counter || !allocatedLength || !string)
        return 1;
    if (wrote > 0)
        (*counter) += wrote;
    else {
        textParser->lastError = ConvertingError;
        free((*string));
        return 2;
    }
    if ((*counter) >= (*allocatedLength) / 2)
        if (TextParser_reallocateString(NULL, string, allocatedLength, (*allocatedLength))) {
            textParser->lastError = MemoryAllocationError;
            free((*string));
            return 3;
        }
    return 0;
}

char* TextParser_convertToText(struct TextParser* textParser) {
    if (!textParser)
        return NULL;
    char* tempString = NULL;
    size_t counter = 0;
    size_t allocatedLength = 5000;
    size_t i = 0;
    size_t j = 0;
    size_t wroteBuf = 0;
    tempString = (char*)malloc(sizeof(char) * allocatedLength);
    if (!tempString) {
        textParser->lastError = MemoryAllocationError;
        return NULL;
    }
    wroteBuf = sprintf(&(tempString[counter]), "/*%s*/\n", TEXT_PARSER_HEADER_COMMENT);
    if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
    for (i = 0; i < textParser->pairsCount; i++) {
        wroteBuf = sprintf(&(tempString[counter]), "%s = ", textParser->pairsList[i].leftValue);
        if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
        wroteBuf = sprintf(&(tempString[counter]), "[\n");
        if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
        for (j = 0; j < textParser->pairsList[i].rightValue.itemsCount; j++) {
            if (j == 0)
                wroteBuf = sprintf(&(tempString[counter]), "\t\"%s\"",
                                textParser->pairsList[i].rightValue.itemsList[j]);
            else
                wroteBuf = sprintf(&(tempString[counter]), ",\n\t\"%s\"",
                                textParser->pairsList[i].rightValue.itemsList[j]);
            if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
                return  NULL;
        }
        wroteBuf = sprintf(&(tempString[counter]), "\n];\n");
        if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
    }
    return tempString;
}
