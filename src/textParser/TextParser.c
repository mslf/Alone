/*
	Copyright 2016 Golikov Vitaliy

	This file is part of Alone.

	Alone is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Alone is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Alone. If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file TextParser.c
 * @author mslf
 * @date 6 Oct 2016
 * @brief File containing implementation of #TextParser.
 */
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include "textParser/TextParser.h"

#define TEXT_PARSER_HEADER_COMMENT "This text resource was generated by TextParser from Alone."

/**
 * @brief Error message strings for #TextParser.
 */
static const struct TextParser_errorMessages {
    const char* const errValueStringAlloc;
    /**< Will be displayed when allocating memory for left or right value strings while parsing #TextResource failed. */
    const char* const errDeletingComments;
    /**< Will be displayed when syntax error or unexpected EOF happened while deleting comment blocks. */
    const char* const errUnexpectedEofWhileSplittingAssigment;
    /**< Will be displayed when unexpected EOF happened while spliting assigment expression. */
    const char* const errSpliting;
    /**< Will be displayed when syntax error happened while spliting assigment expression. */
    const char* const errPairsRealloc;
    /**< Will be displayed when allocating memory for TextParser#pairsList failed. */
    const char* const errItemsRealloc;
    /**< Will be displayed when allocating memory for RightValue#itemsList failed. */
    const char* const errStringAlloc;
    /**< Will be displayed when reallocating memory for some string failed. */
    const char* const errOddQuotesCount;
    /**< Will be displayed when right value string has odd count of quotes. */
    const char* const errUnexpectedEofWhileSplittingArray;
    /**< Will be displayed when unexpected EOF happened while spliting items array for #RightValue. */
    const char* const errBrackets;
    /**< Will be displayed when opening or closing square brackets haven't found while 
     * parsing items array for #RightValue. */
    const char* const errAddingItem;
    /**< Will be displayed when adding item string to #RightValue failed. */
}TextParser_errorMessages = {
    "TextParser_parseTextResource: allocating memory for left or right value strings failed!",
    "TextParser_parseTextResource: syntax error or unexpected EOF while deleting comments!",
    "TextParser_parseTextResource: unexpected EOF while splitting assigment!",
    "TextParser_parseTextResource: syntax error while splitting assigment!",
    "TextParser_reallocatePairsList: allocating memory for pairsList failed!",
    "TextParser_reallocateItemsList: allocating memory for itemsList failed!",
    "TextParser_reallocateString: allocating memory for string failed!",
    "TextParser_addPair: syntax error -  odd count of quotes!",
    "TextParser_addPair: unexpected EOF while parsing items array string!",
    "TextParser_addPair: syntax error - opening or closing square-brackets haven't found!",
    "TextParser_addItemToRightValue: adding item failed!"};

/**
 * @brief States for TextParser_splitExpression() function.
 */
enum TextParser_splittingStates {
        SPLITTING_STATE_START = 0,
        /**< Splitting assigment starts before the assigment (deleting trailing spaces, tabulations and new-lines). */
        SPLITTING_ON_LEFT_PART = 1,
        /**< Splitting assigment now on leftValue part of assigment before '=' symbol (spaces and tabulations will be ignored,
         * but other symbols will be added to the leftValueString). */
        SPLITTING_ON_RIGHT_PART = 2,
        /**< Splitting assigment now on rightValue part of assigment after '=' symbol, but before ';' symbol
         * (spaces and tabulations will be added (if in quotes), but other symbols will be added to the rightValueString).
         * Also all other symbols will be added.*/
        SPLITTING_ON_END = 3,
        /**< Splitting assigment ends succes. */
        SPLITTING_ERR = 4
        /**< Splitting assigment ends with a syntax error. */
};    

/**
 * @brief States for TextParser_parseItemsArrayString() function.
 */
enum TextParser_parsingItemsArrayStates{
        PARSING_ITEMS_ARRAY_NOT_IN_QUOTES = 0,
        /**< Building and adding item string to the Pair#rightValue without ',' symbol. */
        PARSING_ITEMS_ARRAY_IN_QUOTES = 1,
        /**< Building and adding item string to the Pair#rightValue including ',' symbol. */
        PARSING_ITEMS_ARRAY_CHECKING_END = 2,
        /**< Checking for and of items array (']' symbol) or parsing next item in array (',' symbol). */
        PARSING_ITEMS_ARRAY_ON_END = 3,
        /**< Parsing items string ends succes. */
        PARSING_ITEMS_ARRAY_ERR = 4
        /**< Parsing items string  ends with a syntax error. */
};  

/**
 * @brief Reallocates TextParser#pairsList and increases TextParser#allocatedPairsCount 
 * by TextParser_constants#TP_INITIAL_NUMBER_ALLOCATED_PAIRS.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param textParser Pointer to a #TextParser where TextParser#pairsList will be reallocated.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #TextParser_constants
 * @see #TextParser_errorMesssages
 */
static enum TextParser_errors TextParser_reallocatePairsList(struct Logger* logger, struct TextParser* textParser) {
    assert(textParser);
    struct Pair* newPairsList = NULL;
    size_t newSize = textParser->allocatedPairsCount + TP_INITIAL_NUMBER_ALLOCATED_PAIRS;
    // Not realloc because allocating of pair is a two-step process.
    newPairsList = (struct Pair*)malloc(sizeof(struct Pair) * newSize);
    if (!newPairsList) {
        Logger_log(logger, TextParser_errorMessages.errPairsRealloc);
        return TEXT_PARSER_ERR_REALLOC_PAIRS_LIST;
    }
    for (size_t i = 0; i < textParser->pairsCount; i++)
        newPairsList[i] = textParser->pairsList[i];
    for (size_t i = textParser->allocatedPairsCount; i < newSize; i++){
        newPairsList[i].rightValue.itemsCount = 0;
        if (!(newPairsList[i].rightValue.itemsList =
                    (char**)malloc(sizeof(char*) * TP_INITIAL_NUMBER_ALLOCATED_ITEMS))) {
            free(newPairsList);
            return TEXT_PARSER_ERR_ALLOC_STRING;
        }
        newPairsList[i].rightValue.allocatedItemsCount = TP_INITIAL_NUMBER_ALLOCATED_ITEMS;
    }
    free(textParser->pairsList);
    textParser->pairsList = newPairsList;
    textParser->allocatedPairsCount = newSize;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Reallocates RightValue#itemsList and increases RightValue#itemsCount 
 * by TextParser_constants#TP_INITIAL_NUMBER_ALLOCATED_ITEMS.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param rightValue Pointer to a #RightValue where RightValue#itemsList will be reallocated.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #TextParser_constants
 * @see #TextParser_errorMesssages
 */
static enum TextParser_errors TextParser_reallocateItemsList(struct Logger* logger, struct RightValue* rightValue) {
    assert(rightValue);
    char** newItemsList = NULL;
    size_t newSize = rightValue->allocatedItemsCount + TP_INITIAL_NUMBER_ALLOCATED_ITEMS;
    newItemsList = (char**)realloc(rightValue->itemsList, sizeof(char*) * newSize);
    if (!newItemsList) {
        Logger_log(logger, TextParser_errorMessages.errItemsRealloc);
        return TEXT_PARSER_ERR_REALLOC_ITEMS_LIST;
    }
    rightValue->itemsList = newItemsList;
    rightValue->allocatedItemsCount = newSize;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Reallocates string and updates its length counter by step.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param string Pointer to a string (char**) to be reallocated.
 * @param oldLength Pointer to a number, which is an old string length. Will be updated.
 * @param step Reallocation step.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #TextParser_constants
 * @see #TextParser_errorMesssages
 */
static enum TextParser_errors TextParser_reallocateString(struct Logger* logger, char** string, size_t* oldLength, size_t step) {
    assert(string);
    assert(oldLength);
    assert(step != 0);
    char* newString = NULL;
    size_t newLength = (*oldLength) + step;
    newString = (char*)realloc((*string), sizeof(char) * newLength);
    if (!newString) {
        Logger_log(logger, TextParser_errorMessages.errStringAlloc);
        return TEXT_PARSER_ERR_ALLOC_STRING;
    }
    (*string) = newString;
    (*oldLength) = newLength;
    return TEXT_PARSER_NO_ERRORS;
}


/**
 * @brief Escapes space-symbols before left value part of assigment.
 * Adds first symbol of left value part of assigment as found.
 * @param c Current parsing symbol.
 * @param leftValueString Pointer to a string (char**), where this function will store parsed symbols of 
 * left value from assigment. 
 * @param leftCounter Pointer to a number, which is represents current existing chars in leftValueString. 
 * Will be updated while parsing.
 * @return #TextParser_splittingStates value.
 * @see #TextParser_splittingStates
 * @see TextParser_splitExpression()
 */
static enum TextParser_splittingStates TextParser_splitExpressionOnStart(const char c,
                                                                         char** const leftValueString,
                                                                         size_t* const leftCounter) {
    assert(leftValueString && leftCounter);
    if (c == ';')
        return SPLITTING_ERR;
    if (c != ' ' && c!= '\t' && c!= '\n') {
        (*leftValueString)[*leftCounter] = c;
        (*leftCounter)++;
        return SPLITTING_ON_LEFT_PART;
    }
    return SPLITTING_STATE_START;
}

/**
 * @brief Adds symbols to the leftValueString if they are not space-symbols.
 * When it finds '=' symbol, then leftValueString is over.
 * @param c Current parsing symbol.
 * @param leftValueString Pointer to a string (char**), where this function will store parsed symbols of 
 * left value from assigment. 
 * @param leftCounter Pointer to a number, which is represents current existing chars in leftValueString. 
 * Will be updated while parsing.
 * @return #TextParser_splittingStates value.
 * @see #TextParser_splittingStates
 * @see TextParser_splitExpression()
 */
static enum TextParser_splittingStates TextParser_splitExpressionOnLeft(const char c,
                                                                        char** const leftValueString,
                                                                        size_t* const leftCounter) {
    assert(leftValueString && leftCounter);
    if (c == '=' && (*leftCounter) > 0)
        return SPLITTING_ON_RIGHT_PART;
    if (c == '=' && (*leftCounter) == 0)
        return SPLITTING_ERR;
    if (c == '\n' || c == ';')
        return SPLITTING_ERR;
    if (c != ' ' && c != '\t') {
        (*leftValueString)[*leftCounter] = c;
        (*leftCounter)++;
    }
    return SPLITTING_ON_LEFT_PART;
}

/**
 * @brief Adds all symbols to the rightValueString.
 * When it finds ';' symbol, then assigment is done.
 * @param c Current parsing symbol.
 * @param rightValueString Pointer to a string (char**), where this function will store parsed symbols of 
 * right value from assigment. 
 * @param rightCounter Pointer to a number, which is represents current existing chars in rightValueString. 
 * Will be updated while parsing.
 * @return #TextParser_splittingStates value.
 * @see #TextParser_splittingStates
 * @see TextParser_splitExpression()
 */
static enum TextParser_splittingStates TextParser_splitExpressionOnRight(const char c,
                                                                         char** const rightValueString,
                                                                         size_t* const rightCounter) {
    assert(rightValueString && rightCounter);
    if (c == ';' && (*rightCounter) > 0)
        return SPLITTING_ON_END;
    if (c == ';' && (*rightCounter) == 0)
        return SPLITTING_ERR;
    (*rightValueString)[*rightCounter] = c;
    (*rightCounter)++;
    return SPLITTING_ON_RIGHT_PART;
}

/**
 * @brief Splits ';'-terminated assigment for two (left and right) parts.
 * Sets given start index (where function starts to split assigment) to the position of the last readed symbol + 1.
 * Also, sets left and right value string's lengths (and their allocated counter, if needed).
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param string Given string, which will be parsed for assigment.
 * @param startIndex Pointer to a number, from which position this function will start parsing string. 
 * Will be updated while parsing.
 * @param leftValueString Pointer to a string (char**), where this function will store parsed left value from assigment. 
 * Can be reallocated, if needed.
 * @param leftCounter Pointer to a number, which is represents current existing chars in leftValueString. 
 * Will be updated while parsing.
 * @param allocatedCharsForLeftValue Pointer to a value, which is represents current allocated chars in leftValueString. 
 * Will be updated while reallocating leftValueString (if needed).
 * @param rightValueString Pointer to a string (char**), where this function will store parsed right value from assigment. 
 * Can be reallocated, if needed.
 * @param rightCounter Pointer to a number, which is represents current existing chars in rightValueString. 
 * Will be updated while parsing.
 * @param allocatedCharsForRightValue Pointer to a value, which is represents current allocated chars in rightValueString. 
 * Will be updated while reallocating rightValueString (if needed).
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #TextParser_reallocateString
 * @see #TextParser_constants
 * @see #TextParser_errorMesssages
 */
static enum TextParser_errors TextParser_splitExpression(struct Logger* logger,
                                                         const char* const string,
                                                         size_t* const startIndex,
                                                         char** const leftValueString,
                                                         size_t* const leftCounter,
                                                         size_t* const allocatedCharsForLeftValue,
                                                         char** const rightValueString,
                                                         size_t* const rightCounter,
                                                         size_t* const allocatedCharsForRightValue) {
    assert(string);
    assert(startIndex);
    assert(leftValueString && leftCounter && allocatedCharsForLeftValue);
    assert(rightValueString && rightCounter && allocatedCharsForRightValue);
    enum TextParser_splittingStates state = SPLITTING_STATE_START;
    while ((*startIndex) < strlen(string) && state != SPLITTING_ON_END && state != SPLITTING_ERR) {
        char c = string[*startIndex];
        if ((*leftCounter) >= (*allocatedCharsForLeftValue))
            if (TextParser_reallocateString(logger, leftValueString, allocatedCharsForLeftValue,
                                            TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_LEFT_VALUE_STRING))
                return TEXT_PARSER_ERR_ALLOC_STRING;
        if ((*rightCounter) >= (*allocatedCharsForRightValue))
            if (TextParser_reallocateString(logger, rightValueString, allocatedCharsForRightValue,
                                            TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_RIGHT_VALUE_STRING))
                return TEXT_PARSER_ERR_ALLOC_STRING;
        switch (state) {
            case SPLITTING_STATE_START:
                state = TextParser_splitExpressionOnStart(c, leftValueString, leftCounter);
                break;
            case SPLITTING_ON_LEFT_PART:
                state = TextParser_splitExpressionOnLeft(c, leftValueString, leftCounter);
                break;
            case SPLITTING_ON_RIGHT_PART:
                state = TextParser_splitExpressionOnRight(c, rightValueString, rightCounter);
                break;
            default:
                break;
        }
        (*startIndex)++;
    }
    if (state == SPLITTING_ON_END || state == SPLITTING_STATE_START)
        return TEXT_PARSER_NO_ERRORS;
    if (state == SPLITTING_ERR)
        return TEXT_PARSER_ERR_SPLITTING_ASSIGMENT;
    return TEXT_PARSER_ERR_SPLITTING_ASSIGMENT_EOF;
}

/**
 * @brief Removes space-symbols from the string if they are not-quoted.
 * @param c Current parsing symbol.
 * @param position Pointer to a number, which is represents current position in the string. Will be updated, 
 * is the symbol was deleted.
 * @param rightValueString String (char*), where this function will delete space-symbols.
 * @param rightCounter Pointer to a number, which is represents current existing chars in rightValueString. 
 * Will be updated while deleting.
 * @return true, if '"' symbol found, or false if not..
 * @see TextParser_deleteNonQuotedSpaces()
 */
static bool TextParser_deleteNonQuotedSpacesNotInQuotes(const char c,
                                                        size_t* position,
                                                        char* const rightValueString,
                                                        size_t* const rightCounter) {
    assert(position);
    assert(rightValueString && rightCounter);
    if (c == '\"')
        return true;
    if (c == ' ' || c == '\t' || c == '\n') {
        for (size_t j = (*position); j < (*rightCounter) - 1; j++)
            rightValueString[j] = rightValueString[j + 1];
        (*rightCounter)--;
        (*position)--;
    }
    return false;
}

/**
 * @brief Removes space-symbols from the string if they are not-quoted.
 * @param c Current parsing symbol.
 * @param position Pointer to a number, which is represents current position in the string. Will be updated, 
 * is the symbol was deleted.
 * @param rightValueString String (char*), where this function will delete space-symbols.
 * @param rightCounter Pointer to a number, which is represents current existing chars in rightValueString. 
 * Will be updated while deleting.
 * @return false, if '"' symbol found, or true if not..
 * @see TextParser_deleteNonQuotedSpaces()
 */
static bool TextParser_deleteNonQuotedSpacesInQuotes(const char c,
                                                     size_t* position,
                                                     char* const rightValueString,
                                                     size_t* const rightCounter) {
    assert(position);
    assert(rightValueString && rightCounter);
    if (c == '\"')
        return false;
    if (c == '\n') {
        for (size_t j = (*position); j < (*rightCounter) - 1; j++)
            rightValueString[j] = rightValueString[j + 1];
        (*rightCounter)--;
        (*position)--;
    }
    return true;
}

/**
 * @brief Deletes non-quoted space-symbols (space, tabulation, new-line) in string and shifts its content to the left.
 * @param rightValueString String (char*), where this function will delete space-symbols.
 * @param rightCounter Pointer to a number, which is represents current existing chars in rightValueString. 
 * Will be updated while deleting.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 */
static enum TextParser_errors TextParser_deleteNonQuotedSpaces(char* rightValueString, size_t* rightCounter) {
    assert(rightValueString && rightCounter);
    bool inQuotes = false;
    size_t i = 0;
    while (i < (*rightCounter)) {
        char c = rightValueString[i];
        unsigned char state; // Because bool can't be in the switch
        if (inQuotes)
            state = 1;
        else
            state = 0;
        switch (state) {
            case 0: // inQuotes == false
                inQuotes = TextParser_deleteNonQuotedSpacesNotInQuotes(c, &i, rightValueString, rightCounter);
                break;
            case 1: // inQuotes == true
                inQuotes = TextParser_deleteNonQuotedSpacesInQuotes(c, &i, rightValueString, rightCounter);
                break;
        }
        i++;
    }
    if (inQuotes)
        return TEXT_PARSER_ERR_DELETING_NOT_QUOTED_SPACES;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Adds item string to the #Pair.
 * Increases Pair#itemsCount and reallocates Pair#itemsList, if needed.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param pair Pointer to a #Pair where item will be added.
 * @param itemString String, which will be added to the #Pair. Can be not 0-terminated.
 * @param itemStringLength Count of chars, which will be copyed from item string.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 */
static enum TextParser_errors TextParser_addItemToRightValue(struct Logger* logger,
                                                             struct Pair* pair,
                                                             const char* const itemString,
                                                             size_t itemStringLength) {
    assert(pair);
    assert(itemString);
    assert(itemStringLength != 0);
    if (pair->rightValue.itemsCount >=
            pair->rightValue.allocatedItemsCount)
        if (TextParser_reallocateItemsList(logger, &(pair->rightValue)))
            return TEXT_PARSER_ERR_REALLOC_ITEMS_LIST;
    pair->rightValue.itemsList[pair->rightValue.itemsCount] =
            (char*)malloc(sizeof(char) * (itemStringLength + 1));
    if (!pair->rightValue.itemsList[pair->rightValue.itemsCount]) {
        Logger_log(logger, TextParser_errorMessages.errAddingItem);
        return TEXT_PARSER_ERR_ALLOC_STRING;
    }
    for (size_t i = 0; i < itemStringLength; i ++)
        pair->rightValue.itemsList[pair->rightValue.itemsCount][i] = itemString[i];
    pair->rightValue.itemsList[pair->rightValue.itemsCount][itemStringLength] = 0;
    pair->rightValue.itemsCount++;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Adds all symbols (except of ',') to the itemString.
 * When it finds ']' or ',' symbol, then building item string is done and this item will be added to the Pair#rightValue.
 * @param c Current parsing symbol.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param pair Pointer to a #Pair where items will be added.
 * @param itemString String, where current item string is building.
 * @param itemStringLength Length of itemString. Will be increased as new char added to itemString.
 * @return #TextParser_parsingItemsArrayStates value.
 * @see #TextParser_parsingItemsArrayStates
 * @see #Pair
 * @see TextParser_addItemToRightValue()
 * @see TextParser_parseItemsArrayString()
 */
static enum TextParser_parsingItemsArrayStates TextParser_parseItemsArrayStringNotInQuotes(struct Logger* logger,
                                                                                           struct Pair* pair,
                                                                                           const char c,
                                                                                           char* const itemString,
                                                                                           size_t* itemStringLength) {
    assert(pair);
    assert(itemString && itemStringLength);
    if (c == '\"')
         return PARSING_ITEMS_ARRAY_IN_QUOTES;
    if (c == ']') {
        if ((*itemStringLength) > 0) {
            TextParser_addItemToRightValue(logger, pair, itemString, (*itemStringLength));
            (*itemStringLength) = 0;
            return PARSING_ITEMS_ARRAY_ON_END;
        } else
            return PARSING_ITEMS_ARRAY_ERR;
    }
    if (c == ',') {
        TextParser_addItemToRightValue(logger, pair, itemString, (*itemStringLength));
        (*itemStringLength) = 0;
        return PARSING_ITEMS_ARRAY_NOT_IN_QUOTES;
    }
    itemString[(*itemStringLength)] = c;
    (*itemStringLength)++;
    return PARSING_ITEMS_ARRAY_NOT_IN_QUOTES;
}

/**
 * @brief Adds all symbols to the itemString.
 * When it finds '"' symbol, then building item string is done and this item will be added to the Pair#rightValue.
 * @param c Current parsing symbol.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param pair Pointer to a #Pair where items will be added.
 * @param itemString String, where current item string is building.
 * @param itemStringLength Length of itemString. Will be increased as new char added to itemString.
 * @return #TextParser_parsingItemsArrayStates value.
 * @see #TextParser_parsingItemsArrayStates
 * @see #Pair
 * @see TextParser_addItemToRightValue()
 * @see TextParser_parseItemsArrayString()
 */
static enum TextParser_parsingItemsArrayStates TextParser_parseItemsArrayStringInQuotes(struct Logger* logger,
                                                                                           struct Pair* pair,
                                                                                           const char c,
                                                                                           char* const itemString,
                                                                                           size_t* itemStringLength) {
    assert(pair);
    assert(itemString && itemStringLength);
    if (c == '\"') {
        if ((*itemStringLength) > 0) {
            TextParser_addItemToRightValue(logger, pair, itemString, (*itemStringLength));
            (*itemStringLength) = 0;
            return PARSING_ITEMS_ARRAY_CHECKING_END;
        } else
            return PARSING_ITEMS_ARRAY_ERR;
    }
    itemString[(*itemStringLength)] = c;
    (*itemStringLength)++;
    return PARSING_ITEMS_ARRAY_IN_QUOTES;
}

/**
 * @brief Parses string with items and adda them to the #Pair.
 * Strings looks like <tt>[item1, item2, item3]</tt>. If you need strings with spaces in the array, then 
 * you can quote them like this <tt>["item 1", "item 2", "item 3"]</tt>.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param pair Pointer to a #Pair where items will be added.
 * @param itemsString String with array of items.
 * @param itemsStringLength Length of itemsString.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #Pair
 */
static enum TextParser_errors TextParser_parseItemsArrayString(struct Logger* logger,
                                                               struct Pair* pair,
                                                               const char* const itemsString,
                                                               size_t itemsStringLength) {
    assert(pair && itemsString);
    assert(itemsStringLength != 0);
    enum TextParser_parsingItemsArrayStates state = PARSING_ITEMS_ARRAY_NOT_IN_QUOTES;
    size_t i = 1; // start from first symbol, because zero-zymbol is '['
    char* tempItemString = NULL;
    tempItemString = (char*)malloc(sizeof(char) * TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_ITEM_STRING);
    if (!tempItemString)
        return TEXT_PARSER_ERR_ALLOC_STRING;
    size_t allocatedCharsForTempItemString = TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_ITEM_STRING;
    size_t charsCounter = 0;
    while (i < itemsStringLength && state != PARSING_ITEMS_ARRAY_ON_END && state != PARSING_ITEMS_ARRAY_ERR) {
        char c = itemsString[i];
        if (charsCounter >= allocatedCharsForTempItemString)
            if (TextParser_reallocateString(logger, &tempItemString, &allocatedCharsForTempItemString,
                                            TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_ITEM_STRING)) {
                free(tempItemString);
                return TEXT_PARSER_ERR_ALLOC_STRING;
            }
        switch (state) {
            case PARSING_ITEMS_ARRAY_NOT_IN_QUOTES:
                state = TextParser_parseItemsArrayStringNotInQuotes(logger, pair, c, tempItemString, &charsCounter);
                break;
            case PARSING_ITEMS_ARRAY_IN_QUOTES:
                state = TextParser_parseItemsArrayStringInQuotes(logger, pair, c, tempItemString, &charsCounter);
                break;
            case PARSING_ITEMS_ARRAY_CHECKING_END:
                if (c == ',')
                    state = PARSING_ITEMS_ARRAY_NOT_IN_QUOTES;
                else if (c == ']')
                    state = PARSING_ITEMS_ARRAY_ON_END;
                else 
                    state = PARSING_ITEMS_ARRAY_ERR;
                break;
            default:
                break;
        }
        i++;
    }
    free(tempItemString);
    if (state != PARSING_ITEMS_ARRAY_ON_END)
        return TEXT_PARSER_ERR_PARSING_ITEMS_ARRAY_EOF;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Destructs two temp strings.
 * @param left String to be freed.
 * @param right String to be freed.
 */
static void TextParser_destructTempValueStrings(char* left, char* right) {
    free(left);
    free(right);
}

/**
 * @brief Checks rightValue string and adds it (or its items) to the last #Pair in the #TextParser.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param textParser Pointer to a #TextParser, where last (with index of Pair#pairsCount) #Pair in 
 * TextParser#pairsList will be changed
 * (items from rightValue string (or item) will be added to the Pair#rightValue#itemsList).
 * @param rightValueString String with array of items or just one item.
 * @param rightCounter Length of rightValueString.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #Pair
 * @see #RightValue
 */
static enum TextParser_errors TextParser_addPairParsingRightValue(struct Logger* logger,
                                                                  struct TextParser* textParser,
                                                                  char* const rightValueString,
                                                                  size_t rightCounter) {
    assert(textParser);
    assert(rightValueString && rightCounter);
    if (TextParser_deleteNonQuotedSpaces(rightValueString, &rightCounter)) {
        Logger_log(logger, TextParser_errorMessages.errOddQuotesCount);
        return TEXT_PARSER_ERR_DELETING_NOT_QUOTED_SPACES;
    }
    if (rightValueString[0] == '[' && rightValueString[rightCounter - 1] == ']') {
        if (TextParser_parseItemsArrayString(logger, &(textParser->pairsList[textParser->pairsCount]),
                                             rightValueString, rightCounter)) {
            Logger_log(logger, TextParser_errorMessages.errUnexpectedEofWhileSplittingArray);
            return TEXT_PARSER_ERR_PARSING_ITEMS_ARRAY_EOF;
        }
    } else { 
        // adding rightValueString as a first (and only ine) item to the pair
        if (rightValueString[0] == '[' || rightValueString[rightCounter - 1] == ']') {
            Logger_log(logger, TextParser_errorMessages.errBrackets);
            return TEXT_PARSER_ERR_PARSING_ITEMS_ARRAY_BRACKETS;
        }
        enum TextParser_errors result = TEXT_PARSER_NO_ERRORS;
        result = TextParser_addItemToRightValue(logger,
                                                &(textParser->pairsList[textParser->pairsCount]),
                                                rightValueString,
                                                rightCounter);
        if (result)
            return result;
    }
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Adds and inits #Pair in the #TextParser from the value (left and right) strings.
 * @param logger Pointer to a #Logger for logging purpose. Can be NULL.
 * @param textParser Pointer to a #TextParser, where last (with index of Pair#pairsCount) #Pair 
 * in TextParser#pairsList will be changed
 * (items from rightValue string (or item) will be added to the Pair#rightValue#itemsList).
 * @param leftValueString String to set Pair#leftValue.
 * @param leftCounter Length of leftValueString.
 * @param rightValueString String with array of items or just one item.
 * @param rightCounter Length of rightValueString.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #Pair
 * @see #RightValue
 */
static enum TextParser_errors TextParser_addPair(struct Logger* logger,
                                                 struct TextParser* textParser,
                                                 char* const leftValueString,
                                                 size_t leftCounter,
                                                 char* const rightValueString,
                                                 size_t rightCounter) {
    assert(textParser);
    assert(leftValueString && leftCounter);
    assert(rightValueString && rightCounter);
    // adding leftValueString string as a leftValue to the pair
    if (textParser->pairsCount >= textParser->allocatedPairsCount)
        if (TextParser_reallocatePairsList(logger, textParser)) {
            TextParser_destructTempValueStrings(leftValueString, rightValueString);
            return TEXT_PARSER_ERR_REALLOC_PAIRS_LIST;
        }
    textParser->pairsList[textParser->pairsCount].leftValue = (char*)malloc(sizeof(char) * (leftCounter + 1));
    if (!textParser->pairsList[textParser->pairsCount].leftValue) {
        Logger_log(logger, TextParser_errorMessages.errValueStringAlloc);
        TextParser_destructTempValueStrings(leftValueString, rightValueString);
        return TEXT_PARSER_ERR_ALLOC_STRING;
    }
    for (size_t i = 0; i< leftCounter; i ++)
        textParser->pairsList[textParser->pairsCount].leftValue[i] =  leftValueString[i];
    textParser->pairsList[textParser->pairsCount].leftValue[leftCounter] = 0;
    enum TextParser_errors result = TEXT_PARSER_NO_ERRORS;
    result = TextParser_addPairParsingRightValue(logger, textParser, rightValueString, rightCounter);
    if (result) {
        TextParser_destructTempValueStrings(leftValueString, rightValueString);
        return result;
    }
    textParser->pairsCount++;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Removes C-style comment blocks (/_* comment *_/, without of '_') from string.
 * @param srcText String with source text.
 * @param dstText Pointer to a string, where destination text will be placed. Will be null-terminated.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @note You should free memory of dstText by yourself.
 */
static enum TextParser_errors TextParser_deleteComments(const char* srcText, char** dstText) {
    assert(srcText);
    assert(dstText);
    size_t length = strlen(srcText);
    *(dstText) = (char*)malloc(sizeof(char) * (length + 1));
    if (!(*dstText))
        return TEXT_PARSER_ERR_ALLOC_STRING;
    unsigned char state = 0;
    size_t counter = 0;
    size_t i = 0;
    while (i < length) {
        char c = srcText[i];
        switch (state) {
            case 0: // normal text
                if (c == '/') {
                    state = 1;
                    break;
                }
                (*dstText)[counter] = c;
                counter++;
                break;
            case 1: // on "/" (entering comment block)
                if (c == '*') {
                    state = 2;
                    break;
                }
                // FIXME If next char after '/' if a '/', then comment won't be deleted.
                (*dstText)[counter] = '/';
                counter++;
                (*dstText)[counter] = c;
                counter++;
                state = 0;
                break;
            case 2: // in comment block
                if (c == '*')
                    state = 3;
                break;
            case 3: // on "*" (exiting comment block)
                if (c == '/') {
                    state = 0;
                    break;
                }
                state = 2;
                break;
        }
        i++;
    }
    (*dstText)[counter] = 0;
    if (state)
        return TEXT_PARSER_ERR_DELETING_COMMENTS;
    return TEXT_PARSER_NO_ERRORS;
}

/**
 * @brief Parse #TextResource for assigments (#Pair) and adds them to the #TextParser.
 * @param logger Pointer to a #Logger for logging purpose.
 * @param textParser Pointer to a #TextParser, where new #Pair will be added.
 * @param text String with plain text data, to be parsed as a list of assigments.
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @see #Pair
 * @see #TextParser_constants
 * @see #TextParser_errorMesssages
 */
static enum TextParser_errors TextParser_parseText(struct Logger* logger,
                                                           struct TextParser* textParser,
                                                           const char* text) {
    assert(textParser);
    assert(text);
    char* leftValueString = NULL;
    char* rightValueString = NULL;
    leftValueString = (char*)malloc(sizeof(char) * TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_LEFT_VALUE_STRING);
    rightValueString = (char*)malloc(sizeof(char) * TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_RIGHT_VALUE_STRING);
    if (!leftValueString || !rightValueString) {
        Logger_log(logger, "%s \n\t in file: %s", TextParser_errorMessages.errValueStringAlloc, textParser->file);
        TextParser_destructTempValueStrings(leftValueString, rightValueString);
        return TEXT_PARSER_ERR_ALLOC_STRING;
    }
    size_t allocatedCharsForLeftOperand = TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_LEFT_VALUE_STRING;
    size_t allocatedCharsForRightValue = TP_INITIAL_NUMBER_ALLOCATED_SYMBOLS_FOR_RIGHT_VALUE_STRING;
    size_t leftCounter = 0;
    size_t rightCounter = 0;
    size_t i = 0;
    enum TextParser_errors state = TEXT_PARSER_NO_ERRORS;
    char* tempText = NULL;
    if (TextParser_deleteComments(text, &tempText)) {
        Logger_log(logger,
                   "%s \n\t in file: %s", TextParser_errorMessages.errDeletingComments,
                   textParser->file);
        return TEXT_PARSER_ERR_DELETING_COMMENTS;
    }
    while (i < strlen(tempText)) {
        leftCounter = 0;
        rightCounter = 0;
        state = TextParser_splitExpression(logger, tempText, &i, &leftValueString, &leftCounter,
                                           &allocatedCharsForLeftOperand, &rightValueString, &rightCounter,
                                           &allocatedCharsForRightValue);
        if (state == TEXT_PARSER_ERR_SPLITTING_ASSIGMENT_EOF) {
            Logger_log(logger,
                       "%s \n\t in file: %s", TextParser_errorMessages.errUnexpectedEofWhileSplittingAssigment,
                       textParser->file);
            TextParser_destructTempValueStrings(leftValueString, rightValueString);
            return TEXT_PARSER_ERR_SPLITTING_ASSIGMENT_EOF;
        }
        if (state == TEXT_PARSER_ERR_SPLITTING_ASSIGMENT) {
            Logger_log(logger, "%s \n\t in file: %s", TextParser_errorMessages.errSpliting, textParser->file);
            TextParser_destructTempValueStrings(leftValueString, rightValueString);
            return TEXT_PARSER_ERR_SPLITTING_ASSIGMENT;
        }
        if (state == TEXT_PARSER_NO_ERRORS && leftCounter != 0 && rightCounter != 0) {
            enum TextParser_errors result = TextParser_addPair(logger, textParser, leftValueString, leftCounter,
                                                               rightValueString, rightCounter);
            if (result) {
                Logger_log(logger, "\n\t in file: %s", textParser->file);
                return result;
            }
        }
    }
    free(tempText);
    TextParser_destructTempValueStrings(leftValueString, rightValueString);
    return TEXT_PARSER_NO_ERRORS;
}

struct TextParser* TextParser_constructFromTextResource(struct Logger* logger,
                                                        const struct TextResource* const textResource) {
    if (!textResource)
        return NULL;
    struct TextParser* textParser = NULL;
    textParser = TextParser_constructEmpty();
    if (!textParser)
        return NULL;
    textParser->file = textResource->id;
    if (TextParser_parseText(logger, textParser, textResource->text)) {
        TextParser_destruct(textParser);
        return  NULL;
    }
    return textParser;
}

struct TextParser* TextParser_constructEmpty() {
    struct TextParser* textParser = NULL;
    textParser = (struct TextParser*)calloc(1, sizeof(struct TextParser));
    if (!textParser)
        return NULL;
    textParser->file = "NO_FILE";
    textParser->pairsCount = 0;
    textParser->pairsList = (struct Pair*)malloc(sizeof(struct Pair) * TP_INITIAL_NUMBER_ALLOCATED_PAIRS);
    if (!textParser->pairsList) {
        TextParser_destruct(textParser);
        return NULL;
    }
    textParser->allocatedPairsCount = TP_INITIAL_NUMBER_ALLOCATED_PAIRS;
    for (size_t i = 0; i < textParser->allocatedPairsCount; i++){
        textParser->pairsList[i].rightValue.itemsCount = 0;
        if (!(textParser->pairsList[i].rightValue.itemsList =
                    (char**)malloc(sizeof(char*) * TP_INITIAL_NUMBER_ALLOCATED_ITEMS))) {
            TextParser_destruct(textParser);
            return NULL;
        }
        textParser->pairsList[i].rightValue.allocatedItemsCount = TP_INITIAL_NUMBER_ALLOCATED_ITEMS;
    }
    textParser->lastError = TEXT_PARSER_NO_ERRORS;
    return textParser;
}

void TextParser_destruct(struct TextParser* textParser) {
    if (!textParser)
        return;
    if (textParser->pairsList) {
        for (size_t i = 0; i < textParser->allocatedPairsCount; i++) {
            if (i < textParser->pairsCount)
                free(textParser->pairsList[i].leftValue);
            if (i < textParser->pairsCount)
                for (size_t j = 0; j < textParser->pairsList[i].rightValue.itemsCount; j++)
                    free(textParser->pairsList[i].rightValue.itemsList[j]);
            free(textParser->pairsList[i].rightValue.itemsList);
        }
        free(textParser->pairsList);
    }
    free(textParser);
}

size_t TextParser_getItemsCount(struct TextParser* textParser, const char* const leftValue) {
    if (!textParser || !leftValue)
        return 0;
    size_t i = 0;
    for (i = 0; i < textParser->pairsCount; i++)
        if (strcmp(leftValue, textParser->pairsList[i].leftValue) == 0) {
            textParser->lastError = TEXT_PARSER_NO_ERRORS;
            return textParser->pairsList[i].rightValue.itemsCount;
        }
    textParser->lastError = TEXT_PARSER_ERR_NO_LEFT_VALUE_IN_LIST;
    return 0;
}

const char* TextParser_getString(struct TextParser* textParser, const char* const leftValue, size_t index) {
    if (!textParser)
        return NULL;
    if (!leftValue) {
        textParser->lastError = TEXT_PARSER_ERR_NO_LEFT_VALUE_IN_LIST;
        return NULL;
    }
    size_t i = 0;
    unsigned char found = 0;
    size_t foundIndex = 0;
    for (i = 0; i < textParser->pairsCount; i++)
        if (strcmp(leftValue, textParser->pairsList[i].leftValue) == 0) {
            found = 1;
            foundIndex = i;
            break;
        }
    if (!found) {
        textParser->lastError = TEXT_PARSER_ERR_NO_LEFT_VALUE_IN_LIST;
        return NULL;
    }
    if (index >= textParser->pairsList[foundIndex].rightValue.itemsCount) {
        textParser->lastError = TEXT_PARSER_ERR_OUT_OF_RANGE;
        return NULL;
    }
    textParser->lastError = TEXT_PARSER_NO_ERRORS;
    return textParser->pairsList[foundIndex].rightValue.itemsList[index];
}

long int TextParser_getInt(struct TextParser* textParser, const char* const leftValue, size_t index) {
    const char* intString = TextParser_getString(textParser, leftValue, index);
    if (textParser->lastError)
        return 0;
    return strtol(intString, NULL, 10);
}

double TextParser_getDouble(struct TextParser* textParser, const char* leftValue, size_t index) {
    const char* intString = TextParser_getString(textParser, leftValue, index);
    if (textParser->lastError)
        return 0.0;
    return strtod(intString, NULL);
}

bool TextParser_getFlag(struct TextParser* textParser, const char* const leftValue, size_t index){
    const char* intString = TextParser_getString(textParser, leftValue, index);
    if (textParser->lastError)
        return false;
    if (strtol(intString, NULL, 10))
        return true;
    else
        return false;
}

enum TextParser_errors TextParser_addString(struct TextParser* textParser,
                                            const char* const leftValue,
                                            const char* const item) {
    if (!textParser || !leftValue || !item)
        return TEXT_PARSER_ERR_NULL_ARGUMENT;
    TextParser_getItemsCount(textParser, leftValue); // later, we will use textParser->lastError. Don't remove this.
    size_t found = 0;
    size_t index = 0;
    if (textParser->lastError == TEXT_PARSER_ERR_NO_LEFT_VALUE_IN_LIST) {
        if (textParser->pairsCount >= textParser->allocatedPairsCount)
            if (TextParser_reallocatePairsList(NULL, textParser)) {
                textParser->lastError = TEXT_PARSER_ERR_ALLOC_STRING;
                return TEXT_PARSER_ERR_ALLOC_STRING;
            }
        char* tempLeftOperandString = NULL;
        tempLeftOperandString = (char*)malloc(sizeof(char) * (strlen(leftValue) + 1));
        if (!tempLeftOperandString) {
            textParser->lastError = TEXT_PARSER_ERR_ALLOC_STRING;
            return TEXT_PARSER_ERR_ALLOC_STRING;
        }
        strcpy(tempLeftOperandString, leftValue);
        textParser->pairsList[textParser->pairsCount].leftValue = tempLeftOperandString;
        index = textParser->pairsCount;
        textParser->pairsCount++;
    } else if (textParser->lastError == TEXT_PARSER_NO_ERRORS)
        for (size_t i = 0; i < textParser->pairsCount; i++)
            if (strcmp(leftValue, textParser->pairsList[i].leftValue) == 0) {
                found = 1;
                index = i;
                break;
            }
    if (TextParser_addItemToRightValue(NULL, &(textParser->pairsList[index]), item, strlen(item))) {
        textParser->lastError = TEXT_PARSER_ERR_ALLOC_STRING;
        if (!found) {
            free (textParser->pairsList[index].leftValue);
            textParser->pairsCount--;
        }
        return TEXT_PARSER_ERR_ALLOC_STRING;
    }
    textParser->lastError = TEXT_PARSER_NO_ERRORS;
    return TEXT_PARSER_NO_ERRORS;
}

enum TextParser_errors TextParser_addInt(struct TextParser* textParser, const char* const leftValue, long int item) {
    char tempString[100];
    sprintf(tempString, "%ld", item);
    return TextParser_addString(textParser, leftValue, tempString);
}

enum TextParser_errors TextParser_addDouble(struct TextParser* textParser, const char* leftValue, double item) {
    char tempString[100];
    sprintf(tempString, "%f", item);
    return TextParser_addString(textParser, leftValue, tempString);
}

enum TextParser_errors TextParser_addFlag(struct TextParser* textParser, const char* const leftValue, bool item) {
    char tempString[2];
    if (item)
        sprintf(tempString, "1");
    else
        sprintf(tempString, "0");
    return TextParser_addString(textParser, leftValue, tempString);
}

/**
 * @brief Reallocates given string, if its counter number is more then allocated chars for 
 * this string divided by 2.
 * @param textParser Pointer to a #TextParser, where TextParser#lastError will be set.
 * @param wrote Number of last wrote chars to string. Will be added to counter.
 * @param counter Pointer to a number of <B>all</B> wrote chars to string.
 * @param allocatedLength Pointer to a number of allocated chars in string.
 * @param string Pointer to a string, which will be reallocated (if needed).
 * @return #TextParser_errors value.
 * @see #TextParser_errors
 * @note This function destructs given string, if errors happened.
 */
static enum TextParser_errors TextParser_checkWroteCounter(struct TextParser* textParser,
                                                           size_t wrote,
                                                           size_t* counter,
                                                           size_t* allocatedLength,
                                                           char** string) {
    assert(textParser);
    assert(counter);
    assert(allocatedLength);
    assert(string);
    if (wrote > 0)
        (*counter) += wrote;
    else {
        textParser->lastError = TEXT_PARSER_ERR_CONVERTING;
        free((*string));
        return TEXT_PARSER_ERR_CONVERTING;
    }
    if ((*counter) >= (*allocatedLength) / 2)
        if (TextParser_reallocateString(NULL, string, allocatedLength, (*allocatedLength))) {
            textParser->lastError = TEXT_PARSER_ERR_ALLOC_STRING;
            free((*string));
            return TEXT_PARSER_ERR_ALLOC_STRING;
        }
    textParser->lastError = TEXT_PARSER_NO_ERRORS;
    return TEXT_PARSER_NO_ERRORS;
}

char* TextParser_convertToText(struct TextParser* textParser) {
    if (!textParser)
        return NULL;
    char* tempString = NULL;
    size_t counter = 0;
    size_t allocatedLength = 5000;
    size_t wroteBuf = 0;
    tempString = (char*)malloc(sizeof(char) * allocatedLength);
    if (!tempString) {
        textParser->lastError = TEXT_PARSER_ERR_ALLOC_STRING;
        return NULL;
    }
    wroteBuf = sprintf(&(tempString[counter]), "/*%s*/\n", TEXT_PARSER_HEADER_COMMENT);
    if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
    for (size_t i = 0; i < textParser->pairsCount; i++) {
        wroteBuf = sprintf(&(tempString[counter]), "%s = ", textParser->pairsList[i].leftValue);
        if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
        wroteBuf = sprintf(&(tempString[counter]), "[\n");
        if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
        for (size_t j = 0; j < textParser->pairsList[i].rightValue.itemsCount; j++) {
            if (j == 0)
                wroteBuf = sprintf(&(tempString[counter]), "\t\"%s\"",
                                textParser->pairsList[i].rightValue.itemsList[j]);
            else
                wroteBuf = sprintf(&(tempString[counter]), ",\n\t\"%s\"",
                                textParser->pairsList[i].rightValue.itemsList[j]);
            if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
                return  NULL;
        }
        wroteBuf = sprintf(&(tempString[counter]), "\n];\n");
        if (TextParser_checkWroteCounter(textParser, wroteBuf, &counter, &allocatedLength, &tempString))
            return  NULL;
    }
    return tempString;
}
